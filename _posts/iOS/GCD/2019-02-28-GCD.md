---
layout: post
title: GCD 정리
categories: [iOS]
tags: [GCD]
comments: false
---

## GCD

- 멀티코어 프로세서를 위한 Thread 프로그래밍 방법(C Library)입니다. 
- 기존의 쓰레드 관리 기법은 개발자가 직접 락을 걸고, 쓰레드풀을 관리하는 등의 수고가 필요했지만 GCD에서는 Thread를 OS가 자동 관리 및 분배를 해줍니다.
- Dispatch Queue에 Task를 생성해서 집어넣기만 하면 됩니다!

## Dispatch Queue

- Dispatch Queue는 Task를 적재하는 데이터 구조입니다.
- Serial, Concurrent 2가지 방식 존재하고 FIFO 를 따름
- Serial Dispatch Queue : Queue에 Push된 순서대로 1개의 Task씩 실행하며, 해당 Task가 끝나기를 기다립니다. Queue를 여러 개 만들 수도 있으며, 각 Queue들은 Concurrency하게 돌아갑니다.
- Concurrent Dispatch Queue : Global Dispatch Queue라고도 불리며, 여러 개의 task를 Concurrent하게 실행합니다. 실행순서는 Push한 순서대로 실행되며, 동시에 실행되는 Task는 시스템의 환경에 따라 달라집니다.
- Main Dispatch Queue : Application의 Main Thread에서 Serial하게 실행되는 Task들을 관리하는 Queue입니다. 해당 Queue는 Application의 Run loop에서 작동하게 됩니다.
다음으로는 이러한 GCD를 사용하는데 필요한 Block Coding에 대해서 살펴보겠습니다.

### Dispatch Queue 생성

``` objc
// 1-1) serial dispatch queue를 생성합니다.
dispatch_queue_t serialQueue = dispatch_queue_create("test", DISPATCH_QUEUE_SERIAL);
// 1-2) concurrent dispatch queue를 생성합니다.
dispatch_queue_t concurrentQueue = dispatch_queue_create(""test", DISPATCH_QUEUE_CONCURRENT);

// 2) Main Dispatch Queue를 얻어옵니다.
dispatch_queue_t mainQueue = dispatch_get_main_queue();

// 3) Global Dispatch Queue를 얻어옵니다.
dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);

//QOS : DISPATCH_QUEUE_PRIORITY_DEFAULT, Low, Hight, Background 
```

## Dispatch Queue에 Task 추가

###  dispatch_sync

```
 dispatch_sync(queue, ^{
    for (int i=0; i<10; i++) {
        NSLog(@"%d", i);
    }
});
NSLog(@"complte");
// 0~10, complete
```

- 코드가 불리는 쓰레드를 기준으로 싱크하게 실행
- queue에 전달한 코드블럭이 완료되기전까지 기다림
- 따라서, queue가 serial이건 concurrent건 상관없이 무조건 sync하게 동작하게됨

### 1. Serial Dispatch Queue에 Sync하게 Task 추가

``` objc
// 1,2,3
dispatch_queue_t queue = dispatch_queue_create("test", DISPATCH_QUEUE_SERIAL);
dispatch_sync(queue, ^{ NSLog(@"1"); });
dispatch_sync(queue, ^{ NSLog(@"2"); });
dispatch_sync(queue, ^{ NSLog(@"3"); });
```

### 2. Serial Dispatch Queue에 Async하게 Task 추가

- serial queue에 async하게 push해도 순서대로 하나씩 진행하기때문에 아래와 같은 결과
- sync로 추가할때와 차이점은 호출하는 쪽의 코드블럭은 다 수행하고 바로 종료됨
- 따라서, complet가 중간에 바로 출력됨

``` objc
//0~3만까지 출력 다 하고 2,3 찍힘
//complete는 0 출력후에 바로 출력됨
dispatch_queue_t queue2 = dispatch_queue_create("test", DISPATCH_QUEUE_SERIAL);
dispatch_async(queue2, ^{
    for (int i = 0; i < 30000; i++) {
        NSLog(@"%d", i);
    }
});
dispatch_async(queue2, ^{ NSLog(@"2"); });
dispatch_async(queue2, ^{ NSLog(@"3"); });
NSLog(@"complet");
```
### 3. Async Dispatch Queue에 Sync하게 Task 추가

- sync를 한다는건 sync로 넣는 코드블럭자체를 현재의 스레드에서 sync하게 넣는다는 의미
- 그래서 앞선 sync작업이 완료되기전까지 밑에 코드 실행안함

``` objc
//1~1000출력하고 2,3, complete 출력    
dispatch_queue_t queue = dispatch_queue_create("test", DISPATCH_QUEUE_CONCURRENT);
dispatch_sync(queue, ^{
    for (int i=0; i<1000; i++) {
        NSLog(@"%d", i);
    }
});
dispatch_sync(queue, ^{ NSLog(@"2"); });
dispatch_sync(queue, ^{ NSLog(@"3"); });
NSLog(@"complet");
```
### 4. Async Dispatch Queue에 Async하게 Task 추가

- 완전 async함

``` objc
dispatch_queue_t queue = dispatch_queue_create("test", DISPATCH_QUEUE_CONCURRENT);
dispatch_async(queue, ^{
    for (int i=0; i<1000; i++) {
        NSLog(@"%d", i);
    }
});
dispatch_async(queue, ^{ NSLog(@"2"); });
dispatch_async(queue, ^{ NSLog(@"3"); });
NSLog(@"complet");
```
